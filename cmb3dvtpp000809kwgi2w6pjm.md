---
title: "후기: [re:COMMIT] AI 코딩 에이전트, 더 똑똑하게 쓰기"
datePublished: Sun May 25 2025 08:15:34 GMT+0000 (Coordinated Universal Time)
cuid: cmb3dvtpp000809kwgi2w6pjm
slug: recommit-ai
tags: ai, 7is466464ky7zue6riw

---

# 들어가며

최근 'AI 에이전트를 어떻게 활용할 것인가'에 대한 고민은 모든 개발자, 아니 거의 모든 사람들에게 큰 이슈가 되고 있습니다. 저 역시 이러한 고민을 시작한 지 꽤 되었는데요. 처음 AI 없이 개발을 배우기 시작했던 시절을 돌아보면, GPT가 등장하고 이를 적극적으로 활용하면서 정보 습득의 속도가 기하급수적으로 증가했던 것 같습니다. 물론 초기에는 주니어 개발자인 제게도 어설퍼 보였지만, 지금은 놀라운 학습 도우미가 되었습니다.

그때부터 고민의 방향이 달라질 수밖에 없었습니다. 어떻게 AI를 활용해 업무 효율을 높이면서 단순한 AI 트리거가 아닌 '개발자'로서 성장하고 일할 수 있을지에 대한 고민이 시작된 것입니다. 이제 AI를 사용하지 않거나 지양한다는 선택지는 고려 대상이 아니라고 생각합니다.

44bits 채널을 통해 알게 된 Nacyot(김대권)님의 "AI 코딩 에이전트, 더 똑똑하게 쓰기" 세션은 이러한 고민을 하던 저에게 꼭 필요한 주제라 듣기 시작했습니다. 이 글은 해당 영상을 보며 내용을 정리하고 인사이트를 공유한 글입니다.

# Content + Insight

%[https://www.youtube.com/watch?v=LVc3FUDlE7o] 

* Vibe Coding 과 Using LLMs for code responsibly 는 다르다.
    
    * Vibe Coding: LLM 이 작성한 코드를 검토하지 않고 LLM 으로 소프트웨어를 구축하는 것
        
    * **“Using LLMs for code resposibly is not vibe coding“** [**link**](https://simonwillison.net/2025/Mar/19/vibe-coding/)
        
    * <mark>→ 용어를 구별해서 쓰자. AI 가 작성한 코드를 이해하고 책임감을 가져야한다. 그 책임감은 테스트를 통해서 공유된다.</mark>
        
* LLM API 는 stateless 하다.
    
    * <mark>→ LLM 의 비용부과와 동작과정을 이해하면, 더 잘 사용할 수 있게된다.</mark>
        
    * LLM app 은 context 를 갖는 것처럼 보이는 이유, 대화를 할 때마다 이전 대화 기록을 모두 보낸다.
        
    * **Context Window**
        
        * LLM 의 stateless 한 작업 메모리
            
        * 모델이 처리할 수 있는 최대 토큰
            
    * tokenizer 로 토큰을 만들어 전달한다. 실제로 Input 토큰을 굉장히 많이 쓴다.
        
    * 코딩에이전트의 경우
        
        * 파일 목록, 파일 내용, 문서, 컨텍스트, 수정사항 등 모든 내용을 전달하므로 굉장히 많은 리소스를 전달한다.
            
        * cursor 의 경우 이 관리 내용을 공개하고 있지 않아서 이에 대해 의문을 제기하는 사람도 많다.
            
    * 컨텍스트 제한이 걸릴 경우, 내가 하는 작업을 잊어버리는 문제가 발생한다.
        
    * 컨텍스트 윈도우를 최대한 활용하는 것이 좋음.
        
        * 최대 요금제를 사용해보는 것이 차이점을 알기 좋으므로 테스트해보자.
            
* 코딩 에이전트
    
    * 인터페이스, 시스템 프롬프트, 컨텍스트 관리 전략, 도구
        
* 모델은 어떤 것을 선택해야하는가?
    
    * 모델들은 서로 다르게 동작함. 모델마다의 개성이 있으므로 이를 이해하고 쓰면 좋음.
        
* **프롬프트는 어떻게 써야하나?**
    
    * Task 프롬프트: 적절한 작업 단위를 정해줘야함.
        
    * <mark>Goal &amp; Non Goal 을 나눠서 작성</mark>
        
        * 해결해야하는 문제
            
            * «TASK\_DEFINITION»
                
        * 지금 해결할 문제가 아님
            
            * 코드 리팩터링 작업
                
            * 프로젝트 관련 설정이나 구조 변경
                
            * **<mark>→ 이것을 해주지 않으면 AI 의 작업범위가 무한정 늘어나게 되고, 작업 속도가 지연될 수밖에 없다. 잘 활용해보자.</mark>**
                
        * **<mark>→ 대화 진입점에 Goal &amp; Non Goal 을 제시하여 경계를 넘지 않도록 한다.</mark>**
            
    * 강조사항
        
        * 작업에 대한 설명은 간결하게만 해줘
            
        * 문제는 최대한 단순하게 접근하고, 최대한 쉽게 해결할 것
            
        * <mark>테스트 먼저 구현하고 코드 구현</mark>
            
        * <mark>코드 작성 이후 반드시 테스트 실행해서 문제 확인할 것</mark>
            
            * <mark>→ 정말 사람 개발자처럼 일하도록 시킨다고 생각한다.</mark>
                
        * 파일 읽기에 실패하면 해당 파일을 만들지 말고 검색해볼 것. 명시적인 요청이 있을 때에만 생성.
            
        * 개발 서버 실행하지 말 것. 브라우저 도구는 명시적인 요청시에만 사용.
            
    * 사전 작업
        
        * **다음의 문서들을 반드시 읽을 것**
            
            * 모듈 구성
                
                * 테스트 위치는 /spec …
                    
            * 테스트 팩토리 파일은 단수를 사용함 등
                
            * 작업 전에 테스트 설정 파일을 미리 확인
                
            * 테스트 기본 원칙
                
                * 한번에 하나씩 해결
                    
                * 테스트 작성 후 직접 실행하고 실패하는 테스트는 하나씩 성공 시킬 것.
                    
                * 변경사항과 에러메시지를 집중적으로 분석후 테스트 실행.
                    
                * 다수가 실패하는 경우엔 카테고리화하되, 한꺼번에 해결하지 말 것.
                    
                * 하나를 해결하고 다시 테스트하는 방식으로.
                    
            * 테스트 실패시 디버깅 전략
                
                * 특정 파일을 함부로 수정하지 말 것.
                    
        * 마지막 커밋 이후에 변경사항이 있는지 Git으로 확인할 것
            
        * **<mark>깨지는 테스트가 있는지 확인할 것.</mark>**
            
            * 깨지는 테스트가 있으면 작업 중지.
                
            * → 테스트의 의미가 재정의된다.
                
    * 프롬프트 노하우 정리
        
        * 왕도는 없지만 기본에 충실
            
        * 작업 내용은 최대한 자세히 작성
            
            * 너무 추상적이지 않은, 적절한 작업 단위로 작성
                
            * 예상되는 부작용과 영향 범위에 대해서도 전달
                
        * Goal 과 Non Goal 을 정의
            
        * Snipetty 등 스닛펫 앱이나 확장 사용
            
        * 사용자 프롬프트도 작성할지 고민 필요 (강조사항, 사전 작업 둥)
            
    * 프롬프트와 컨텍스트 관리
        
        * 에이전트가 문제를 해결하는 공간을 최적화
            
        * 적당한 타이밍, 적당한 위치에 컨텍스트를 넣어주는 것이 좋음.
            
        * 사용자 프롬프트는 진입점이기 때문에 그때그때 동적으로 변경하기 좋음
            
        * 시스템 프롬프트는 사전정의하기 좋음.
            
        * MCP를 통한 피드백. 작업 중간에 추가적인 컨텍스트 제공
            
        * 코멘트에 써두면, 파일에 대한 컨텍스트를 동적으로 제공함. # 이부분은 수정하지 말것 등등…
            
            * 코딩에이전트와 협업을할때는 많이 활용하기 좋음
                
            * <mark>→ 코멘트에 부정적이었더라도 다시 고려해보자</mark>
                
        * 그러나 주의하자.
            
            * 적용할 규칙이 많다고 좋은 건 아님.
                
            * 기본 컨텍스트 윈도우가 커짐. Input 토큰 소모
                
            * 규칙이 많아지면 무시하는 경우도 많아짐.
                
            * 꼭 필요한 최소한만 Active 하게 유지. (적용범위, 규칙 수)
                
            * 모든 내용을 지키지는 않음.
                
                * 파일 읽기나 규칙이 무시되는 경우가 많음.
                    
                * 모델에 따라 동작이 일관적이지 않음.
                    
* 개발 환경 구축
    
    * 나와 코딩 에이전트가 함께 사용하는 개발 환경
        
    * 프로젝트에 대한 의존성, virtualenv, direnv 등 사전에 셋업해야함.
        
* 테스트
    
    * **<mark>정교한 코드 실행, 더 강력한 피드백 수단</mark>**
        
    * “어느정도 숙련된 개발자라면, 코딩 에이전트 사용해보면 테스트가 얼마나 중요한지 곧바로 깨달을 거라고 생각함. 코딩 에이전트라는 게, 피드백이 없으면 그냥 멍청한 환각병 LLM 임.”
        
    * 회귀 테스트
        
        * 코드 작성 전, 후로 깨진 코드가 없는지 모든 테스트 실행
            
    * 시스템 테스트
        
        * 브라우저 자동화를 통한 테스트가 힘듬. 피드백 환경 구축이 어려움
            
        * 피드백 개선 전략
            
            * console.log 나 네트워크 호출 로그를 터미널로 전달
                
            * 테스트 실패한 스크린샷을 전달하는 방법
                
* 어떻게 잘 동작하는가?
    
    * 두뇌
        
        * Model
            
        * Messages
            
    * **작업환경 ✨**
        
        * 에이전트
            
            * 인터페이스
                
            * 시스템 프롬프트
                
                * 도구 정의
                    
            * 컨텍스트 윈도우 관리
                
        * 에디터
            
            * 도구 실행환경
                
            * 개발환경
                
                * Dev Container
                    
            * MCP
                
                * 도구 확장
                    
            * 사용자
                
                * 컨텍스트 윈도우 활용
                    
                * 피드백 루프
                    
                    * 개발 환경
                        
                    * 테스트
                        
                * 프롬프트 개선
                    
                * 컨텍스트 관리
                    
                    * 문서
                        
* 앞으로에 대하여…
    
    * 코딩은 적용하기 쉬운 환경이었을지도 모른다.
        
        * 폐쇄된 작업 환경과 피드백 루프
            
    * 내 문제를 해결하기 위한 프로그래밍을 할 수 있음
        
    * AI will be Writing 90% of Code of 3 to 6 Months.
        
        * 앞으로는 이런 미래가 올지모른다.
            
    * 우리가 알고 있는 프로그래밍의 종말
        
        * The End of Programming as We Know It [link](https://www.oreilly.com/radar/the-end-of-programming-as-we-know-it/)
            
        * 프로그래밍의 의미는 아이디어를 재정렬해서 실행하능하도록 하는 것으로 바뀔 것이다.
            
        * 코딩의 종말이 곧 프로그래밍의 종말은 아니지 않을까?